/*
 * Copyright 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//
// JavaCC grammar specification for a Soy file.
//
// @author Kai Huang


// =================================================================================================
// Options
// =================================================================================================

options {
  JDK_VERSION = "1.7";
  STATIC = false;
  UNICODE_INPUT = true;
  DEBUG_TOKEN_MANAGER = false;
  DEBUG_PARSER = false;
  SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
}


// =================================================================================================
// Parser class
// =================================================================================================


PARSER_BEGIN(SoyFileParser)

package com.google.template.soy.soyparse;

import com.google.common.base.CharMatcher;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicates;
import com.google.common.collect.FluentIterable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.template.soy.base.SourceLocation;
import com.google.template.soy.base.internal.IdGenerator;
import com.google.template.soy.base.internal.LegacyInternalSyntaxException;
import com.google.template.soy.base.internal.SoyFileKind;
import com.google.template.soy.base.internal.SoyFileSupplier.Version;
import com.google.template.soy.error.ErrorReporter.Checkpoint;
import com.google.template.soy.error.ErrorReporter;
import com.google.template.soy.error.SoyErrorKind;
import com.google.template.soy.exprparse.SoyParsingContext;
import com.google.template.soy.soytree.AliasDeclaration;
import com.google.template.soy.soytree.CallBasicNode;
import com.google.template.soy.soytree.CallDelegateNode;
import com.google.template.soy.soytree.CallNode;
import com.google.template.soy.soytree.CallParamContentNode;
import com.google.template.soy.soytree.CallParamNode;
import com.google.template.soy.soytree.CallParamValueNode;
import com.google.template.soy.soytree.CssNode;
import com.google.template.soy.soytree.DebuggerNode;
import com.google.template.soy.soytree.ForNode;
import com.google.template.soy.soytree.ForeachNode;
import com.google.template.soy.soytree.IfCondNode;
import com.google.template.soy.soytree.IfElseNode;
import com.google.template.soy.soytree.IfNode;
import com.google.template.soy.soytree.LetContentNode;
import com.google.template.soy.soytree.LetNode;
import com.google.template.soy.soytree.LetValueNode;
import com.google.template.soy.soytree.LogNode;
import com.google.template.soy.soytree.MsgFallbackGroupNode;
import com.google.template.soy.soytree.MsgHtmlTagNode;
import com.google.template.soy.soytree.MsgNode;
import com.google.template.soy.soytree.MsgPlaceholderNode;
import com.google.template.soy.soytree.MsgPluralCaseNode;
import com.google.template.soy.soytree.MsgPluralDefaultNode;
import com.google.template.soy.soytree.MsgPluralNode;
import com.google.template.soy.soytree.MsgSelectCaseNode;
import com.google.template.soy.soytree.MsgSelectDefaultNode;
import com.google.template.soy.soytree.MsgSelectNode;
import com.google.template.soy.soytree.NameAttributePair;
import com.google.template.soy.soytree.NamespaceDeclaration;
import com.google.template.soy.soytree.PrintDirectiveNode;
import com.google.template.soy.soytree.PrintNode;
import com.google.template.soy.soytree.RawTextNode;
import com.google.template.soy.soytree.SoyFileNode;
import com.google.template.soy.soytree.SoyNode.MsgPlaceholderInitialNode;
import com.google.template.soy.soytree.SoyNode.StandaloneNode;
import com.google.template.soy.soytree.SoyNode.StatementNode;
import com.google.template.soy.soytree.SwitchCaseNode;
import com.google.template.soy.soytree.SwitchDefaultNode;
import com.google.template.soy.soytree.SwitchNode;
import com.google.template.soy.soytree.TemplateBasicNodeBuilder;
import com.google.template.soy.soytree.TemplateDelegateNodeBuilder;
import com.google.template.soy.soytree.TemplateNode.SoyFileHeaderInfo;
import com.google.template.soy.soytree.TemplateNode;
import com.google.template.soy.soytree.TemplateNodeBuilder.DeclInfo;
import com.google.template.soy.soytree.TemplateNodeBuilder;
import com.google.template.soy.soytree.XidNode;
import com.google.template.soy.types.SoyTypeRegistry;

import java.io.*;
import java.util.*;
import java.util.regex.*;


/**
 * This parser's specification is in SoyFileParser.jj, which is read by JavaCC and transformed
 * into SoyFileParser.java. To modify this parser, please edit SoyFileParser.jj. Do not edit
 * SoyFileParser.java directly.
 *
 * <p> Important: Do not use outside of Soy code (treat as superpackage-private).
 *
 * <pre>
 * This parser parses the following Soy file structure:
 *
 * 1. Delegate package (delpackage):
 *    + Optional.
 *    + The file must contain 0 or 1 delpackage declaration.
 *    + It must appear before the namespace declaration.
 *    + It must appear on its own line and start at the start of a line.
 *    Example:  {delpackage MySecretFeature}
 *
 * 2. Namespace:
 *    + The file must contain exactly one namespace declaration.
 *    + It must appear before any templates.
 *    + It must appear on its own line and start at the start of a line.
 *    Examples:
 *    {namespace boo.foo}
 *    {namespace boo.foo autoescape="..."}
 *
 * 3. Alias:
 *    + Alias declarations must appear after the namespace declaration.
 *    + They must appear before any templates.
 *    + Each must appear on its own line and start at the start of a line.
 *    Examples:
 *    {alias boo.foo.goo.moo}
 *    {alias boo.foo.goo.moo as zoo}
 *
 * 4. SoyDoc:
 *    + Starts with slash-star-star (/**) and ends with star-slash (*&#47;) like JavaDoc.
 *    + SoyDoc must appear on its own line(s) and start at the start of a line.
 *    + Currently recognizes two tags: "&#64;param keyName" and "&#64;param? optionalKeyName".
 *    Example:
 *    /**
 *     * &#64;param boo Something scary.
 *     * &#64;param? goo Something slimy (optional).
 *     *&#47;
 *
 * 5. Template:
 *    + Each template must be immediately preceded by a SoyDoc block.
 *    + The 'template' tag and the '/template' tag much each appear on its own line(s) and start
 *      at the start of a line.
 *    + The template content is parsed by TemplateParser.jj.
 *    Examples:
 *    /**
 *     * New style.
 *     * &#64;param boo Something scary.
 *     * &#64;param? goo Something slimy (optional).
 *     *&#47;
 *    {template .foo autoescape="..."}
 *      {msg desc=""}
 *        {$boo} has a friend named {$goo.firstName}.
 *      {/msg}
 *    {/template}
 *
 * 6. Misc:
 *    + Other than the items specified above, everything else is ignored.
 *    + SoyDoc blocks not immediately followed by a template are ignored.
 *    + The file must end with a newline.
 *
 * Template contents are parsed as follows:
 * Header:
 *
 * 1. Comments:
 *    + Comments are only allowed outside of Soy tags.
 *    + Standard "//" for a rest-of-line comment. Must appear at start of line or after a space.
 *    + Standard slash-star (/*) ... star-slash (*&#47;) for a block comment.
 *    + Doc comments are not allowed, except when attached to a valid declaration.
 *
 * 2. Param declaration:
 *    + Soy tag with command name "@param" and command text "key: type".
 *    + Optional desc string is written as a block doc comment, which either must
 *      precede the param tag, or must start on the same line as the end of the '@param' tag.
 *    + Examples:
 *    {@param foo: bool}
 *    {@param foo: list<int>}  /** A list of numbers. *&#47;
 *    {@param? foo:
 *        list<int>}  /**
 *        A list of numbers. *&#47;
 *
 * 3. Injected param declaration:
 *    + Works exactly like @param except that parameter values are taken from the
 *      implicit $ij scope.
 *    + Soy tag with command name "@inject" and command text "key: type".
 *    + Optional desc string is written as a block doc comment, which either must
 *      precede the param tag, or must start on the same line as the end of the '@inject' tag.
 *    + Examples:
 *    {@inject foo: bool}
 *    {@inject foo: list<int>}  /** A list of numbers. *&#47;
 *    {@inject? foo:
 *        list<int>}  /**
 *        A list of numbers. *&#47;
 *
 * Body:
 *
 * 1. Soy tag format:
 *    + Can be delimited by single braces "{...}".
 *    + } characters are only allowed in tags if they're inside string literals.
 *    + Some Soy tags are allowed to end in "/}" to denote immediate ending of a block.
 *    + It is an error to use "/}" when it's not applicable to the command.
 *    + If there is a command name, it must come immediately after the opening delimiter.
 *    + The command name must be followed by either the closing delimiter (if the command does not
 *      take any command text) or a whitespace (if the command takes command text).
 *    + It is an error to provide command text when it's not applicable, and vice versa.
 *    + This parser does not parse command text (that will be separate).
 *    Examples:
 *    {print $boo}   // explicit 'print' command
 *    {$boo.foo}   // implicit 'print' command
 *    {printer}   // implicit 'print' command (the prefix 'print' here is not a command name)
 *    {\n}   // a command that doesn't take any command text
 *    {call .gooMoo data="all" /}   // self-ending block
 *    {call .gooMoo data="all"}...{/call}   // block with separate start and end tags
 *
 * 2. Raw text:
 *    + Raw text is fixed text that will be part of the template output. There are 3 types.
 *    + Any text outside of Soy tags is raw text.
 *    + There are 7 special character commands that produce raw text strings:
 *      {sp} = space   {nil} = empty string   {\n} = newline (line feed)   {\r} = carriage return
 *      {\t} = tab   {lb} = left brace   {rb} = right brace
 *    + A section of raw text (may contain braces) can be enclosed within a 'literal' block:
 *      {literal}...{/literal}
 *
 * 3. Msg blocks:
 *    + A block between 'msg' and '/msg' tags represents a message for translation.
 *    + It is an error to nest 'msg' blocks.
 *    + Within a 'msg' block, the parsing of Soy tags is the same. The only difference is that we
 *      also recognize "&lt;" and "&gt;" as opening and closing an HTML tag. This is because each
 *      HTML tag as a whole needs to be turned into a single placeholder in the message.
 *    + A 'msg' block may have a 'plural' or 'select' block as its only content.
 *    + A 'msg' block may be followed by optional additional 'fallbackmsg' blocks.
 *    Example:
 *    {msg desc="Event title."}
 *      Join event &lt;a href="{$event.url}"&gt;{$event.title}&lt;/a&gt;.
 *    {fallbackmsg desc="Event title."}
 *      Join event {$event.title}.
 *    {/msg}
 *
 * 4. Other Soy commands:
 *    {print ...}
 *    {...}    // implied 'print' command
 *    {xid ...}
 *    {css ...}
 *    {let ... /}
 *    {let ...}...{/let}
 *    {if ...}...{elseif ...}...{else ...}...{/if}
 *    {switch ...}{case ...}...{default}...{/switch}
 *    {foreach ...}...{ifempty}...{/foreach}
 *    {for ...}...{/for}
 *    {call ... /}
 *    {delcall ... /}
 *    {call ...}{param ... /}{param ...}...{/param}{/call}
 *    {delcall ...}{param ... /}{param ...}...{/param}{/delcall}
 *    {log}...{/log}
 *    {debugger}
 *
 * 5. Misc:
 *    + The following commands are not allowed to appear in a template:
 *      {namespace ...}   {template ...}   {/template}
 * </pre>
 *
 * <p>TODO(lukes):  This parser has a lot of issues:
 * Too much parsing logic is handled by the AST nodes with regular expressions.  This is probably
 * slower than handling it in the parser and it leads to redundant error handling code.
 *
 */
public class SoyFileParser {
  // Template parser regexes:
  /** Regex string used in patterns below. Note the first set of spaces is reluctant. */
  private static final String LINE_BOUNDARY_REGEX = "\\s*?(\\n|\\r)\\s*";

  /** Pattern for a line boundary. */
  private static final Pattern LINE_BOUNDARY_PATTERN = Pattern.compile(LINE_BOUNDARY_REGEX);

  /** Pattern for a line boundary appearing at the start edge of the string being matched. */
  private static final Pattern START_EDGE_LINE_BOUNDARY_PATTERN =
      Pattern.compile("^" + LINE_BOUNDARY_REGEX);

  /** Pattern for a line boundary appearing at the end edge of the string being matched. */
  private static final Pattern END_EDGE_LINE_BOUNDARY_PATTERN =
      Pattern.compile(LINE_BOUNDARY_REGEX + "$");

  /** Pattern for a line boundary not appearing at either edge of the string being matched. */
  private static final Pattern NONEDGE_LINE_BOUNDARY_PATTERN =
      Pattern.compile("(?<=\\S)" + LINE_BOUNDARY_REGEX + "(?=\\S)");

  static class RegexFromTokenImageFunction implements Function<String, String> {
    @Override public String apply(String o) {
      // Strip the surrounding quotes and braces.
      return Pattern.quote(o.substring(2, o.length() - 2));
    }
  };
  /** Pattern for invalid implicit print prefixes (used to throw errors for invalid commands). */
  private static final Pattern INVALID_PRINT_PREFIX_PATTERN = Pattern.compile(
      // tokenImage contains token names for error messages. For literal tokens, it stores the token
      // value as-is, wrapped in quotes. Use this to extract simple token names without duplication.
      "^(" + Joiner.on("|").join(FluentIterable.from(Arrays.asList(tokenImage))
              .filter(Predicates.containsPattern("^\"\\{[a-z]+\\}\"$"))
              .transform(new RegexFromTokenImageFunction()))
      + ")\\b.+");

  /** Pattern for invalid implicit print prefixes (used to throw errors for invalid commands). */
  private static final Pattern INVALID_PRINT_FILE_PREFIX_PATTERN = Pattern.compile(
      "^(namespace|(del)?template|typedef|alias)\\b.*");


  private static final SoyErrorKind UNCATEGORIZED = SoyErrorKind.of("In file {0}, template {1}: {2}");

  private static final SoyErrorKind MISMATCHED_CLOSING_TAG =
      SoyErrorKind.of("''{0}'' has mismatched closing tag ''{1}''.");

  // Template errors:
  private static final SoyErrorKind UNEXPECTED_CLOSING_TAG =
      SoyErrorKind.of("Unexpected closing tag ''{0}''.");

  private static final SoyErrorKind FOUND_DOUBLE_BRACE =
      SoyErrorKind.of("Soy '{{command}}' syntax is no longer supported.  Use single braces.");

  private static final SoyErrorKind INVALID_DECLARATION =
      SoyErrorKind.of("Invalid declaration ''{0}''.");

  private static final SoyErrorKind INVALID_PRINT_PREFIX =
      SoyErrorKind.of("Command ''{0}'' cannot have arguments.");

  private static final SoyErrorKind INVALID_PRINT_FILE_COMMAND =
      SoyErrorKind.of("Command ''{0}'' cannot appear in templates.");

  private static final SoyErrorKind PLURAL_AND_SELECT_NOT_ALLOWED_INSIDE_PLURAL_BLOCK =
      SoyErrorKind.of("Tags ''plural'' and ''select'' are not allowed inside ''plural'' blocks.");

  private static final SoyErrorKind MULTIPLE_PHNAME_ATTRIBUTES_IN_COMMAND = SoyErrorKind.of(
      "Found multiple ''phname'' attributes in ''{0}'' command text \"{1}\".");

  private static final SoyErrorKind PRINT_COMMAND_WITH_EMPTY_TEXT =
      SoyErrorKind.of("Found ''print'' command with empty command text.");

  private static final SoyErrorKind INVALID_PRINT_COMMAND_TEXT =
      SoyErrorKind.of("Invalid ''print'' command text \"{0}\" (check the directives).");


  /** Type registry for resolving type names. */
  private SoyTypeRegistry typeRegistry;

  /** Node id generator for the tree being built. */
  private IdGenerator nodeIdGen;

  /** The kind of this Soy file. */
  private SoyFileKind soyFileKind;

  /** Path of source being parsed. This is descriptive, not a means to refetch source. */
  private String filePath;

  private ErrorReporter errorReporter;

  /** Can only be used in templates. */
  private SoyParsingContext context;

  /**
   * Constructor that takes a reader object providing the input.
   * @param typeRegistry The type registry for resolving type names.
   * @param nodeIdGen The node id generator for the tree being built.
   * @param input The input to parse.
   * @param soyFileKind The kind of this Soy file.
   * @param filePath The path of the source being parsed. Used for reporting.
   * @param errorReporter For reporting parse errors.
   */
  public SoyFileParser(
      SoyTypeRegistry typeRegistry,
      IdGenerator nodeIdGen,
      Reader input,
      SoyFileKind soyFileKind,
      String filePath,
      ErrorReporter errorReporter) {
    this(input);
    Preconditions.checkNotNull(typeRegistry);
    Preconditions.checkNotNull(nodeIdGen);
    this.typeRegistry = typeRegistry;
    this.nodeIdGen = nodeIdGen;
    this.soyFileKind = soyFileKind;
    this.filePath = filePath;
    this.errorReporter = errorReporter;
  }

  /**
   * Attempts to parse the given input as a Soy file, returns null if parsing fails.
   */
  public SoyFileNode parseSoyFile() {
    Preconditions.checkNotNull(typeRegistry);
    Preconditions.checkNotNull(nodeIdGen);
    Checkpoint checkpoint = errorReporter.checkpoint();
    SoyFileNode soyFileNode = null;
    try {
      soyFileNode = SoyFile();
    } catch (ParseException e) {
      ParseErrors.reportSoyFileParseException(errorReporter, filePath, e);
    } catch (LegacyInternalSyntaxException e) {
      ParseErrors.report(errorReporter, filePath, e);
    } catch (TokenMgrError e) {
      // Should only happen if we make a mistake in the token manager.
      // TODO(lukes): Make sure this really never happens, then remove the catch block.
      ParseErrors.reportUnexpected(errorReporter, filePath, e);
    }
    // our callers expect us to return null when encountering parsing errors.
    if (errorReporter.errorsSince(checkpoint)) {
      return null;
    }
    return soyFileNode;
  }

  private <T> SourceItemInfo<T> newSourceItemInfo(T parsed, Token token) {
    return newSourceItemInfo(
        parsed, token.beginLine, token.beginColumn, token.endLine, token.endColumn);
  }
  private <T> SourceItemInfo<T> newSourceItemInfo(T parsed, Token begin, Token end) {
    return newSourceItemInfo(
        parsed, begin.beginLine, begin.beginColumn, end.endLine, end.endColumn);
  }

  private <T> SourceItemInfo<T> newSourceItemInfo(T parsed, SourceItemInfo<?> begin,
      SourceItemInfo<?> end) {
    return new SourceItemInfo<T>(parsed, begin, end);
  }

  private <T> SourceItemInfo<T> newSourceItemInfo(
      T parsed, int lineNum, int columnNum, int lineNumEnd, int columnNumEnd) {
    return new SourceItemInfo<T>(filePath, parsed,
        lineNum, columnNum,
        lineNumEnd, columnNumEnd);
  }


  private SourceLocation createSrcLoc(Token tok1, Token ...rest) {
    return Tokens.createSrcLoc(filePath, tok1, rest);
  }
}

PARSER_END(SoyFileParser)


// =================================================================================================
// Tokens
// =================================================================================================


TOKEN_MGR_DECLS:
{
  // Template parser:

  /**
   * Whether we're within a 'msg' block. We need to record this because we sometimes leave
   * states TEMPLATE_DEFAULT_AT_SOL* (e.g. to parse a Soy tag) and then when we're done, we need to
   * know which TEMPLATE_DEFAULT_AT_SOL* state to return to. See switchToStateDefault*() below.
   */
  private boolean isInMsgBlock = false;

  /** Whether we're within an HTML tag. Only applicable within a 'msg' block */
  private boolean isInMsgHtmlTag = false;



  /**
   * Helper for lexical actions to switch back to one of the states TEMPLATE_DEFAULT_AT_SOL or
   * TEMPLATE_DEFAULT_IN_MSG_BLOCK_AT_SOL, depending on whether we're currently within a msg block.
   */
  private void switchToStateDefaultAtSol() {
    if (isInMsgBlock) {
      SwitchTo(TEMPLATE_DEFAULT_IN_MSG_BLOCK_AT_SOL);
    } else {
      SwitchTo(TEMPLATE_DEFAULT_AT_SOL);
    }
  }


  /**
   * Helper for lexical actions to switch back to one of the states TEMPLATE_DEFAULT_NOT_SOL or
   * TEMPLATE_DEFAULT_IN_MSG_BLOCK_NOT_SOL, depending on whether we're currently within a msg block.
   */
  private void switchToStateDefaultNotSol() {
    if (isInMsgBlock) {
      SwitchTo(TEMPLATE_DEFAULT_IN_MSG_BLOCK_NOT_SOL);
    } else {
      SwitchTo(TEMPLATE_DEFAULT_NOT_SOL);
    }
  }

  // Wrapper to prevent unreachable statement errors after throw
  private void throwPoisonToken(String message, Token token) {
    throw new PoisonTokenException(message, token);
  }

  /**
   * Thrown from an invalid token to skip the rest of the containing {template}.
   * See consumeUntilTemplateClose
   */
  final class PoisonTokenException extends RuntimeException {
    public final String message;
    public final Token token;
    public PoisonTokenException(String message, Token token) {
      super(message);
      this.message = message;
      this.token = token;
    }
  }
}

// Tips on writing a good lexer
// https://javacc.java.net/doc/lexertips.html

// =================================================================================================
// File (non-template) tokens
// =================================================================================================

// Skip whitespace and comments
SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")?>
}

<DEFAULT> MORE: {
 "/*" : IN_MULTILINE_COMMENT
}

<IN_MULTILINE_COMMENT> MORE : {
  < ~[] >
}

<IN_MULTILINE_COMMENT> SKIP : {
  "*/" : DEFAULT
}


<DEFAULT> TOKEN : {
  <RBRACE : "}">
| <EQ : "=">
| <AS: "as">
| <ALIAS_OPEN: "{alias">
| <CSSBASE: "cssbase">
| <NAMESPACE_OPEN: "{namespace">
| <AUTOESCAPE: "autoescape">
| <REQUIRECSS: "requirecss">
| <DELPACKAGE_OPEN: "{delpackage">
| <ATTRIBUTE_VALUE:
    "\""
    (
     // TODO(lukes): we should probably have a way to escape double quotes within the attribute
     // value
      ~["\""]
    )*
    "\""
  >
| <DOTTED_IDENT: <IDENT> ( (<WS>)* "." (<WS>)* <IDENT> )*>
}

// Templates

<DEFAULT> TOKEN : {
  < #TEMPLATE_OPEN_SUFFIX: (<WS>)+ ( ~["}"] )+ "}">
| <DELTEMPLATE_OPEN: "{deltemplate" <TEMPLATE_OPEN_SUFFIX>> : TEMPLATE_DEFAULT_NOT_SOL
| <TEMPLATE_OPEN: "{template" <TEMPLATE_OPEN_SUFFIX>> : TEMPLATE_DEFAULT_NOT_SOL
}

// SOYDOC
// Capture all soydoc into a SPECIAL_TOKEN.
// SPECIAL_TOKEN (http://www.engr.mun.ca/~theo/JavaCC-FAQ/javacc-faq-moz.htm#tth_sEc3.10)
// is a special javacc mechanism whereby we can create a 'token' that isn't directly passed to the
// parser. Normally, the stream of text gets turned into a stream of 'tokens' that then get matched
// by the parser.  A SPECIAL_TOKEN is just like a normal token, except it is not directly passed to
// the parser.  Instead, SPECIAL_TOKENs can be accessed via the normal tokens that immediately
// follow them via the Token.specialToken field.
// This behavior is useful for matching SoyDoc since we are really only interested in soydoc that
// immediately precedes template definitions.  We could theoretically handle this by creating non
// terminal for matching soydoc and then writing a BNF expression for it.  However, then we would
// have to write BNF expressions to match (and ignore) soydoc in all other contexts, which would be
// tedious.

<DEFAULT> MORE : {
   "/**" : IN_SOYDOC
}

<IN_SOYDOC> MORE : {
  < ~[] >
}

<IN_SOYDOC> SPECIAL_TOKEN : {
  <SOYDOC: "*/" > : DEFAULT
}

// Match everything else as an 'unexpected' token to prevent TokenMgrErrors from being thrown and
// instead this will get turned into ParseExceptions which have more debugging information.
// TODO(slaks): Apply to all states.
<DEFAULT> TOKEN : {
    < UNEXPECTED_TOKEN : ~[] >
}

// =================================================================================================
// Template tokens (only used inside templates)
// =================================================================================================

// -------------------------------------------------------------------------------------------------
// Line comment.

// Comments are only recognized in states TEMPLATE_DEFAULT_AT_SOL*.

// The only difference between TEMPLATE_DEFAULT*_AT_SOL and TEMPLATE_DEFAULT*_NOT_SOL is that the
// former allow a line comment to start without preceding whitespace.

<TEMPLATE_DEFAULT_AT_SOL, TEMPLATE_DEFAULT_IN_MSG_BLOCK_AT_SOL> SKIP:
{
  < LINE_COMMENT_AT_SOL: ( <WS_NOT_NL> )? "//" ( <NOT_NL> )* >
  { switchToStateDefaultNotSol(); }
}

<TEMPLATE_DEFAULT_NOT_SOL, TEMPLATE_DEFAULT_IN_MSG_BLOCK_NOT_SOL> SKIP:
{
  < LINE_COMMENT_NOT_SOL: <WS_NOT_NL> "//" ( <NOT_NL> )* >
}


// -------------------------------------------------------------------------------------------------
// Block comment.

<TEMPLATE_DEFAULT_AT_SOL, TEMPLATE_DEFAULT_NOT_SOL, TEMPLATE_DEFAULT_IN_MSG_BLOCK_AT_SOL, TEMPLATE_DEFAULT_IN_MSG_BLOCK_NOT_SOL> SKIP:
{
  < BLOCK_DOC_COMMENT_START: "/**" > : IN_BLOCK_DOC_COMMENT
|
  < BLOCK_NONDOC_COMMENT_START: "/*" > : IN_BLOCK_NONDOC_COMMENT
}

// Collect the block comment text using MORE and return it when we reach the "*/" token.
// TODO(lukes): Use a SPECIAL token to collect the SoyDoc into the {@param} token automatically.
<IN_BLOCK_DOC_COMMENT, IN_BLOCK_NONDOC_COMMENT> MORE:
{
  < BLOCK_COMMENT_CHAR: <ANY_CHAR> >
}

<IN_BLOCK_DOC_COMMENT> TOKEN:
{
  < BLOCK_DOC_COMMENT: "*/" >
  { // Remove the "*/" token and trim the contents.
    matchedToken.image = image.substring(0, image.length() - 2).trim();
    switchToStateDefaultNotSol();
  }
}

<IN_BLOCK_NONDOC_COMMENT> TOKEN:
{
  < BLOCK_NONDOC_COMMENT: "*/" >
  { // Remove the "*/" token and trim the contents.
    matchedToken.image = image.substring(0, image.length() - 2).trim();
    switchToStateDefaultNotSol();
  }
}


// -------------------------------------------------------------------------------------------------
// Soy commands.

// ------------ Step 1: Match an opening tag (or full self-closing tag) ------------
// Prefixes:
//  - FULL for self-closing tags (return to default state after token, with no context for tag)
//  - OPEN for complete opening tags (switch to content or default state, but expect closing tag)
//  - BEGIN for incomplete opening tags (switch to IN_CMD_TAG to expect command parameters)
//  - CLOSE for closing tags (return to default state)
// OPEN tags must include trailing whitespace, to prevent them from matching implicit print commands
// which begin with the same characters (eg, `{format(blah)}`).

// IN_CMD_TAG_STRUCTURED is used for commands that parse their command text in the tokenizer. It has
// tokens for each valid construct that can appear in these tags.
// IN_CMD_TAG_UNSTRUCTURED is for older or more-complex tags that are parsed through regexes, or the
// expression parser.  It swallows any kind of token into CMD_TEXT_ARBITRARY_TOKEN.

<TEMPLATE_DEFAULT_AT_SOL, TEMPLATE_DEFAULT_NOT_SOL, TEMPLATE_DEFAULT_IN_MSG_BLOCK_AT_SOL, TEMPLATE_DEFAULT_IN_MSG_BLOCK_NOT_SOL> TOKEN:
{
  <CMD_CLOSE_TEMPLATE        : "{/template}"> : DEFAULT
| <CMD_CLOSE_DELTEMPLATE     : "{/deltemplate}"> : DEFAULT

| < DECL_BEGIN_PARAM         : "{@param"    > : IN_CMD_TAG_STRUCTURED
| < DECL_BEGIN_INJECT_PARAM  : "{@inject"   > : IN_CMD_TAG_STRUCTURED
| < XXX_BRACE_INVALID          : "}" >
  { throwPoisonToken("Unexpected }; did you mean '{rb}'?", matchedToken); }

| < CMD_FULL_SP              : "{sp}"       > { switchToStateDefaultNotSol(); }
| < CMD_FULL_NIL             : "{nil}"      > { switchToStateDefaultNotSol(); }
| < CMD_FULL_LF              : "{\\n}"      > { switchToStateDefaultNotSol(); }
| < CMD_FULL_CR              : "{\\r}"      > { switchToStateDefaultNotSol(); }
| < CMD_FULL_TAB             : "{\\t}"      > { switchToStateDefaultNotSol(); }
| < CMD_FULL_LB              : "{lb}"       > { switchToStateDefaultNotSol(); }
| < CMD_FULL_RB              : "{rb}"       > { switchToStateDefaultNotSol(); }

| < CMD_OPEN_LITERAL         : "{literal}"  > : IN_LITERAL_BLOCK

| < CMD_BEGIN_CALL           : ("{call" | "{delcall")  <WS> > : IN_CMD_TAG_UNSTRUCTURED
| < CMD_CLOSE_CALL           : "{/call}" | "{/delcall}" > { switchToStateDefaultNotSol(); }

| < CMD_BEGIN_PARAM          : "{param" <WS>     > : IN_CMD_TAG_UNSTRUCTURED
| < CMD_CLOSE_PARAM          : "{/param}"   > { switchToStateDefaultNotSol(); }

| < CMD_BEGIN_MSG            : "{msg" <WS>  > { isInMsgBlock = true; SwitchTo(IN_CMD_TAG_UNSTRUCTURED); }
| < CMD_BEGIN_FALLBACK_MSG   : "{fallbackmsg" <WS> > : IN_CMD_TAG_UNSTRUCTURED
| < CMD_CLOSE_MSG            : "{/msg}"     > {
    if (isInMsgHtmlTag) {
      throwPoisonToken(
          "Found '/msg' tag while within an HTML tag in a 'msg' block. Please close the HTML" +
          " tag before ending the 'msg' block.", matchedToken);
    }
    isInMsgBlock = false;
    SwitchTo(TEMPLATE_DEFAULT_NOT_SOL);
  }

| < CMD_BEGIN_PRINT          : "{print" <WS> > : IN_CMD_TAG_UNSTRUCTURED
| < CMD_BEGIN_XID            : "{xid" <WS>  > : IN_CMD_TAG_UNSTRUCTURED
| < CMD_BEGIN_CSS            : "{css" <WS>  > : IN_CMD_TAG_UNSTRUCTURED

| < CMD_BEGIN_IF             : "{if" <WS>     > : IN_CMD_TAG_UNSTRUCTURED
| < CMD_BEGIN_ELSEIF         : "{elseif" <WS> > : IN_CMD_TAG_UNSTRUCTURED
| < CMD_FULL_ELSE            : "{else}"     > { switchToStateDefaultNotSol(); }
| < CMD_CLOSE_IF             : "{/if}"      > { switchToStateDefaultNotSol(); }

| < CMD_BEGIN_LET            : "{let" <WS>  > : IN_CMD_TAG_UNSTRUCTURED
| < CMD_CLOSE_LET            : "{/let}"     > { switchToStateDefaultNotSol(); }

| < CMD_BEGIN_FOR            : "{for" <WS>       > : IN_CMD_TAG_UNSTRUCTURED
| < CMD_CLOSE_FOR            : "{/for}"     > { switchToStateDefaultNotSol(); }

| < CMD_BEGIN_PLURAL         : "{plural" <WS>    > : IN_CMD_TAG_UNSTRUCTURED
| < CMD_CLOSE_PLURAL         : "{/plural}"  > { switchToStateDefaultNotSol(); }

| < CMD_BEGIN_SELECT         : "{select" <WS>    > : IN_CMD_TAG_UNSTRUCTURED
| < CMD_CLOSE_SELECT         : "{/select}"  > { switchToStateDefaultNotSol(); }

| < CMD_BEGIN_SWITCH         : "{switch" <WS>    > : IN_CMD_TAG_UNSTRUCTURED
| < CMD_CLOSE_SWITCH         : "{/switch}"  > { switchToStateDefaultNotSol(); }

| < CMD_FULL_DEFAULT         : "{default}"  > { switchToStateDefaultNotSol(); }
| < CMD_BEGIN_CASE           : "{case" <WS> > : IN_CMD_TAG_UNSTRUCTURED

| < CMD_BEGIN_FOREACH        : "{foreach" <WS> > : IN_CMD_TAG_UNSTRUCTURED
| < CMD_FULL_IFEMPTY         : "{ifempty}"  > { switchToStateDefaultNotSol(); }
| < CMD_CLOSE_FOREACH        : "{/foreach}" > { switchToStateDefaultNotSol(); }

| < CMD_OPEN_LOG             : "{log}"      > { switchToStateDefaultNotSol(); }
| < CMD_CLOSE_LOG            : "{/log}"     > { switchToStateDefaultNotSol(); }
| < CMD_FULL_DEBUGGER        : "{debugger}" > { switchToStateDefaultNotSol(); }
| < CMD_BEGIN_IMPLICIT_PRINT : "{"          > : IN_CMD_TAG_UNSTRUCTURED
}


// ------------ Step 2: Match the command text and closing delimiter ------------

<IN_CMD_TAG_UNSTRUCTURED, IN_CMD_TAG_STRUCTURED> TOKEN: {
  < CMD_END : "}" > { switchToStateDefaultNotSol(); }
| < CMD_SELF_CLOSE : "/}" > { switchToStateDefaultNotSol(); }
| < CMD_TEXT_DIRECTIVE_NAME: "|" <IDENT> >
// TODO(lukes): Once we merge in the ExpressionParser, use NameAttributePair () instead.
| < CMD_TEXT_PHNAME_ATTR: <WS_CHAR> "phname=\"" <IDENT> "\"" >
| < XXX_CMD_TEXT_PHNAME_NOT_IDENT: <WS_CHAR> "phname=\"" ( ~["\""] )* "\"" >
  { throwPoisonToken(
        "Found 'phname' attribute that is not a valid identifier (" + matchedToken.image + ").",
        matchedToken);
  }
}

<IN_CMD_TAG_STRUCTURED> TOKEN: {
  < NAME : <IDENT> >
| < CMD_TYPE_PREFIX : (<WS>)* ":" (<WS>)* > : IN_TYPE_LITERAL
}

<IN_TYPE_LITERAL> TOKEN: {  // TODO(slaks): Replace with actual type parser.
  < CMD_TYPE_LITERAL : ( ~["}"] )+ > : IN_CMD_TAG_STRUCTURED
}

<IN_CMD_TAG_UNSTRUCTURED> TOKEN: {
  // Allow any non-string token, or complete quoted string literals.
  < CMD_TEXT_ARBITRARY_TOKEN:
      ~["'", "\"", "}"]
    // | ("/" ~["}"])  // Allow /, but not /} (so we don't swallow self-closing tags)
    | "\""
      (
          ~["\"","\\"]
        | "\\" ~[]
      )*
      "\""
    // Must match <STRING> in ExpressionParser.jj, but allow newlines and lowercase hex literals
    // (for legacy templates).
    | "'"
      (
          ~["'","\\"]
        | "\\" ["n","r","t","b","f","\\","'","\""]
        | "\\u" (["0"-"9","A"-"F", "a"-"f"]){4}
      )*
      "'"
  >
  // Force friendly error messages by providing a token to match error cases.
| <XXX_INVALID_STRING_LITERAL: ["'", "\""]>
  { throwPoisonToken("Invalid string literal found in Soy command.", matchedToken); }
}


// -------------------------------------------------------------------------------------------------
// In a 'msg' block.

// The only difference between states TEMPLATE_DEFAULT_AT_SOL/TEMPLATE_DEFAULT_NOT_SOL and
// TEMPLATE_DEFAULT_IN_MSG_BLOCK_AT_SOL/TEMPLATE_DEFAULT_IN_MSG_BLOCK_NOT_SOL is that the latter
// also create tokens for HTML tag open/close.
<TEMPLATE_DEFAULT_IN_MSG_BLOCK_AT_SOL, TEMPLATE_DEFAULT_IN_MSG_BLOCK_NOT_SOL> TOKEN:
{
  < MSG_HTML_TAG_OPEN: "<" >
  { if (isInMsgHtmlTag) {
      throwPoisonToken("In a 'msg' block, found '<' within HTML tag.", matchedToken);
    }
    isInMsgHtmlTag = true;
  }
|
  < MSG_HTML_TAG_CLOSE: ">" >
  { if (!isInMsgHtmlTag) {
      throwPoisonToken("In a 'msg' block, found '>' outside HTML tag.", matchedToken);
    }
    isInMsgHtmlTag = false;
  }
}


// -------------------------------------------------------------------------------------------------
// In a 'literal' block.

// Collect the literal text using MORE.
<IN_LITERAL_BLOCK> MORE:
{
  < <ANY_CHAR> >
}

// When we reach the '/literal' tag, return the collected text content (minus the end tag).
<IN_LITERAL_BLOCK> TOKEN:
{
  < LITERAL_RAW_TEXT_CONTENT: "{/literal}" >
  {
    // Note: 'image' is cumulative over MOREs while 'lengthOfMatch' is just the end tag length.
    matchedToken.image = image.substring(0, image.length() - lengthOfMatch);
    switchToStateDefaultNotSol();
  }
}


// -------------------------------------------------------------------------------------------------
// Misc.

<TEMPLATE_DEFAULT_AT_SOL, TEMPLATE_DEFAULT_NOT_SOL, TEMPLATE_DEFAULT_IN_MSG_BLOCK_AT_SOL, TEMPLATE_DEFAULT_IN_MSG_BLOCK_NOT_SOL> TOKEN:
{
  < TOKEN_NL: <NL> >
  { switchToStateDefaultAtSol(); }
|
  < TOKEN_WS_NOT_NL: <WS_NOT_NL> >
  { switchToStateDefaultNotSol(); }
|
  < TOKEN_NOT_WS: <NOT_WS> >
  { switchToStateDefaultNotSol(); }
}

// Private helper regexes.
<*> TOKEN:
{
  < #ANY_CHAR: ~[] >
|
  < WS: " " | "\t" | "\n" | "\r" | "\r\n" >
|
  < #WS_CHAR: " " | "\t" | "\n" | "\r" >
|
  < #NOT_WS: ~[" ","\t","\n","\r"] >
|
  < #NL: "\n" | "\r" | "\r\n" >
|
  < #NOT_NL: ~["\n","\r"] >
|
  < #WS_NOT_NL: " " | "\t" >
|
  < #BRACE: ["{","}"] >
|
  < QMARK: ["?"] >
|
  < #IDENT: ["a"-"z","A"-"Z","_"] ( ["a"-"z","A"-"Z","_","0"-"9"] )* >
}

// TODO(slaks): Merge in type tokens (used in templates and in typedefs)

// =================================================================================================
// Grammar
// =================================================================================================


/**
 * Matches the whole input if it is a valid Soy file.
 *
 * SoyFile -> [ DelpackageTag ] [ NamespaceTag ] ( AliasTag )* ( Template )* EOF
 */
private SoyFileNode SoyFile() :
{
  TemplateNode template;
  String delpackageName = null;
  NamespaceDeclaration namespace = NamespaceDeclaration.NULL;
  List<TemplateNode> templates = new ArrayList<TemplateNode>();
  List<AliasDeclaration> aliases = new ArrayList<AliasDeclaration>();
  AliasDeclaration alias = null;
  // note we generate the id first to avoid having to edit every test that asserts on node ids.
  int id = nodeIdGen.genId();
}
{
  [ delpackageName = DelPackage() ]

  [ namespace = Namespace() ]

  (
    alias = Alias()
    { aliases.add(alias); }
  )*

  {
    SoyFileHeaderInfo soyFileHeaderInfo = new SoyFileHeaderInfo(errorReporter,
      delpackageName, namespace, aliases);
    context = SoyParsingContext.create(errorReporter, soyFileHeaderInfo.namespace,
        soyFileHeaderInfo.aliasToNamespaceMap);
  }

  (
    try {
      template = Template(soyFileHeaderInfo)
      { templates.add(template); }
    } catch (ParseException e) {
      ParseErrors.reportSoyFileParseException(errorReporter, filePath, e);
      consumeUntilTemplateClose();
    } catch(SoyFileParserTokenManager.PoisonTokenException e) {
      errorReporter.report(createSrcLoc(e.token), SoyErrorKind.of("{0}"), e.message);
      consumeUntilTemplateClose();
      // TODO(slaks): Also check the the close token matches open?
    }
  )*

  <EOF>

  {
    SoyFileNode sfn =
        new SoyFileNode(
            id,
            filePath,
            soyFileKind,
            namespace,
            soyFileHeaderInfo);
    sfn.addChildren(templates);
    return sfn;
  }
}

/**
 * Matches an {alias ...} declaration.
 */
private AliasDeclaration Alias() :
{
  Token open, namespace, close;
  Token alias = null, as = null;
}
{
  (
    open = <ALIAS_OPEN>
    namespace = <DOTTED_IDENT>
    [
      as = <AS>
      alias = <DOTTED_IDENT>
    ]
    close = <RBRACE>
  )
  {
    return alias == null
        ? new AliasDeclaration(
            namespace.image,
            errorReporter,
            createSrcLoc(open, namespace, close))
        : new AliasDeclaration(
            namespace.image,
            alias.image,
            errorReporter,
            createSrcLoc(open, namespace, as, alias, close));
  }
}

/**
 * Matches a {namespace ...} declaration.
 */
private NamespaceDeclaration Namespace() :
{
  Token open, name, close;
  NameAttributePair attr;
  List<NameAttributePair> attributes = new ArrayList<NameAttributePair>();
}
{
  open = <NAMESPACE_OPEN>
  name = <DOTTED_IDENT>
  (
    attr = Attribute()
    { attributes.add(attr); }
  )*
  close = <RBRACE>
  {
    return new NamespaceDeclaration(name.image, attributes, errorReporter);
  }
}

/**
 * Matches a name value pair.
 *
 * <p>Currently this is hardcoded to handle a fixed set of keys, which means
 * adding a new attribute will require a parser change.  Alternatively, we could
 * match all possible keys and figure out if they were appropriate later.
 * 'Hardcoding' the keys is pretty easy for now and will allow the tokenizer to
 * issue reasonable error messages.
 */
private NameAttributePair Attribute() :
{
  Token name;
  Token eq;
  Token value;
}
{
  (
      name = <AUTOESCAPE>
    | name = <REQUIRECSS>
    | name = <CSSBASE>
  )
  eq = <EQ>
  value = <ATTRIBUTE_VALUE>
  {
    return new NameAttributePair(
        name.image,
        // trim quotes off the token
        value.image.substring(1, value.image.length() - 1),
        createSrcLoc(name, eq, value));
  }
}

/**
 * Matches a {delpackage ...} declaration.
 *
 * <p>Currently this just returns the parsed name, we should consider returning
 * some object with source location information.
 */
private String DelPackage() :
{
  Token name;
}
{
  <DELPACKAGE_OPEN>
  name = <DOTTED_IDENT>
  <RBRACE>
  {
    return name.image;
  }
}


/**
 * Template -> AnyTemplateTag TemplateContent
 * @param soyFileHeaderInfo Info from the containing Soy file's header declarations. Needed by the
 *     TemplateNode constructors.
 */
private TemplateNode Template(SoyFileHeaderInfo soyFileHeaderInfo) :
{
  Token open, close;
  boolean isBasicTemplate;
  List<DeclInfo> templateHeaderDecls = null;
  List<StandaloneNode> templateBodyNodes = null;
  String openTagName;
}
{
  // First, parse the opening tag and set up the classes need for the template parser.
  (
      (
        open = <TEMPLATE_OPEN>
        { isBasicTemplate = true; }
      )
    | (
        open = <DELTEMPLATE_OPEN>
        { isBasicTemplate = false; }
      )
  )

  {
    SourceLocation srcLocation = createSrcLoc(open);

    TemplateNodeBuilder templateNodeBuilder = isBasicTemplate
        ? new TemplateBasicNodeBuilder(
            soyFileHeaderInfo, srcLocation, errorReporter, typeRegistry)
        : new TemplateDelegateNodeBuilder(
            soyFileHeaderInfo, srcLocation, errorReporter, typeRegistry);

    templateNodeBuilder.setId(nodeIdGen.genId());

    // --- Set the command text. ---
    // trim the leading tag name and the trailing '}'
    openTagName = open.image.substring(0, isBasicTemplate ? 10 : 13);
    String cmdText = open.image.substring(openTagName.length(), open.image.length() - 1);
    templateNodeBuilder.setCmdText(cmdText);

    // --- Set the SoyDoc. ---
    // special tokens are accessible from the non-special tokens that come after them.
    Token soyDoc = open.specialToken;
    if (soyDoc != null && soyDoc.kind == SOYDOC) {
      templateNodeBuilder.setSoyDoc(soyDoc.image);
    } else {
      templateNodeBuilder.setSoyDoc(null);
    }
  }

  // Once the parser is set up, parse any parameter declarations
  (
    LOOKAHEAD( TemplateHeaderLookaheadHelper() )
    templateHeaderDecls = TemplateHeader()
    { templateNodeBuilder.setHeaderDecls(templateHeaderDecls); }
  |
    // If no template header, ignore initial indent at start of template body.
    [ HeaderConsecWsNoNl() ]
  )

  // Next, parse the actual content.
  templateBodyNodes = TemplateBlock()

  // Finally, consume the closing tag (and make sure it matches the opening tag).
  (
      (
        close = <CMD_CLOSE_TEMPLATE>
        {
          if (!isBasicTemplate) {
            errorReporter.report(createSrcLoc(close), MISMATCHED_CLOSING_TAG,
                openTagName + templateNodeBuilder.getTemplateNameForUserMsgs(), close.image);
          }
        }
      )
    | (
        close = <CMD_CLOSE_DELTEMPLATE>
        {
          if (isBasicTemplate) {
            errorReporter.report(createSrcLoc(close), MISMATCHED_CLOSING_TAG,
                openTagName + templateNodeBuilder.getTemplateNameForUserMsgs(), close.image);
          }
        }
      )
  )

  {
    TemplateNode templateNode = templateNodeBuilder.build();
    if (templateBodyNodes != null) {
        templateNode.addChildren(templateBodyNodes);
    }
    return templateNode;
  }

}


JAVACODE
/** Discards all remaining tokens from the current template after encountering an error. */
private void consumeUntilTemplateClose() {
  token_source.SwitchTo(TEMPLATE_DEFAULT_NOT_SOL);
  Token t = null;
  do {
    // Ignore errors from the tokens we consume.
    try {
      t = getNextToken();
    } catch (SoyFileParserTokenManager.PoisonTokenException e) {}
  } while (t == null || // Ignore other posion tokens
      (t.kind != EOF && t.kind != CMD_CLOSE_TEMPLATE && t.kind != CMD_CLOSE_DELTEMPLATE));
}

// =================================================================================================
// Grammar - Templates
// =================================================================================================


// =================================================================================================
// Grammar basics
// =================================================================================================


// -------------------------------------------------------------------------------------------------
// Soy tag parts.

/**
 * TODO(slaks): Eventually, replace this with tokens for actual command content (eg, attributes).
 * CmdText -> CmdTextParts
 */
private String CmdText():
{
  List<String> cmdTextParts;
}
{
  cmdTextParts = CmdTextParts()
  { return Joiner.on("").join(cmdTextParts); }
}


/**
 * CmdTextParts -> ( CmdTextToken | CmdTextDirectiveName | CmdTextPhnameAttr )*
 */
private List<String> CmdTextParts() :
{
  Token cmdTextChar;
  Token cmdTextSpecialPart;
}
{
  { List<String> cmdTextParts = Lists.newArrayList();
    StringBuilder currCmdTextPartSb = new StringBuilder();
  }
  (
    (
      cmdTextChar = <CMD_TEXT_ARBITRARY_TOKEN> { currCmdTextPartSb.append(cmdTextChar.image); }
    | (
        cmdTextSpecialPart = <CMD_TEXT_DIRECTIVE_NAME>
      | cmdTextSpecialPart = <CMD_TEXT_PHNAME_ATTR>
      )
      { // Add the preceding part if nonempty.
        if (currCmdTextPartSb.length() > 0) {
          cmdTextParts.add(currCmdTextPartSb.toString());
          currCmdTextPartSb = new StringBuilder();
        }
        // Add the special part.
        cmdTextParts.add(cmdTextSpecialPart.image);
      }
    )
  )*

  { // Add the last part if nonempty.
    if (currCmdTextPartSb.length() > 0) {
      cmdTextParts.add(currCmdTextPartSb.toString());
      currCmdTextPartSb = new StringBuilder();
    }

    // Process whitespace.
    // TODO(user): this is the beginning of a code path that should be eliminated.
    // These trimmed command strings are typically passed into Node constructors and then
    // re-passed into the expression parser for further parsing. The trimming and re-parsing
    // makes it hard to reconstruct accurate source location information for expression trees.
    // This file should be the source of truth for all source location information in Soy.
    for (int i = 0, n = cmdTextParts.size(); i < n; i++) {
      String cmdTextPart = cmdTextParts.get(i);
      if (i == 0) {
        cmdTextPart = CharMatcher.whitespace().trimLeadingFrom(cmdTextPart);
      }
      if (i == n - 1) {
        cmdTextPart = CharMatcher.whitespace().trimTrailingFrom(cmdTextPart);
      }
      cmdTextPart = LINE_BOUNDARY_PATTERN.matcher(cmdTextPart).replaceAll(" ");
      cmdTextParts.set(i, cmdTextPart);
    }

    return cmdTextParts;
  }
}

// -------------------------------------------------------------------------------------------------
// Whitespace strings. These rules do not skip block doc comments (but do skip nondoc comments).
// Used for parsing the template header. Do not use for parsing basic raw text in the template body.


/**
 * HeaderConsecWsNoNl -> ( TokenWsNotNl | BlockNondocComment )+
 */
private void HeaderConsecWsNoNl() : {}
{
  ( <TOKEN_WS_NOT_NL> | <BLOCK_NONDOC_COMMENT> )+
}


/**
 * HeaderConsecWs  -> HeaderConsecWsWithNl | HeaderConsecWsNoNl
 */
private void HeaderConsecWs() : {}
{
  ( <TOKEN_NL> | <TOKEN_WS_NOT_NL> | <BLOCK_NONDOC_COMMENT> )+
}


// -------------------------------------------------------------------------------------------------
// Raw text.


/**
 * BlockCommentToken -> BlockDocComment | BlockNondocComment
 */
private Token BlockCommentToken() :
{
  Token token;
}
{
  (
    token = <BLOCK_DOC_COMMENT>
  |
    token = <BLOCK_NONDOC_COMMENT>
  )

  { return token; }
}



/**
 * BasicRawTextToken -> TokenNl | TokenWsNotNl | TokenNotWs
 */
private Token BasicRawTextToken() :
{
  Token token;
}
{
  (
    token = <TOKEN_NL>
  | token = <TOKEN_WS_NOT_NL>
  | token = <TOKEN_NOT_WS>
  )

  { return token; }
}


/**
 * BasicRawText -> ( BasicRawTextToken | BlockCommentToken )+
 *
 * Important: Since this is used for parsing basic raw text in the body of templates, we apply
 * line-joining rules here.
 */
private SourceItemInfo<String> BasicRawText() :
{
  Token token;
}
{
  {
    StringBuilder basicRawTextSb = new StringBuilder();
    int lineNum = -1;
    int columnNum = -1;
  }

  (
    // Needed because this can be called before another expansion that can also consume <TOKEN_NL>.
    LOOKAHEAD(2)
    (
      token = BasicRawTextToken()
      { basicRawTextSb.append(token.image); }
    |
      // Skip block comments (doc and nondoc).
      token = BlockCommentToken()
    )
    {
      if (lineNum == -1) {
        lineNum = token.beginLine;
        columnNum = token.beginColumn;
      }
    }
  )+

  { String basicRawText = basicRawTextSb.toString();
    // TODO(lukes): Move all of this logic to RawTextNode.
    // Handle line boundaries after Soy tags (includes stripping end-of-template space since input
    // ends with a newline).
    basicRawText = START_EDGE_LINE_BOUNDARY_PATTERN.matcher(basicRawText).replaceFirst("");

    // Adjust line by counting forward for each newline removed.
    // So far, we have only removed content from the beginning of the string.
    int numSpaceCharsRemovedFromFront = basicRawTextSb.length() - basicRawText.length();
    for (int i = 0; i < numSpaceCharsRemovedFromFront; ++i) {
      char ch = basicRawTextSb.charAt(i);
       if (ch == '\r') {
        if (i + 1 == numSpaceCharsRemovedFromFront || basicRawTextSb.charAt(i + 1) != '\n') {
          ++lineNum;  // Only count this CR if it is not part of a CRLF.
          columnNum = 1;
        }
      } else if (ch == '\n') {
        ++lineNum;
        columnNum = 1;
      }
    }

    // Handle line boundaries before Soy tags (includes stripping end-of-template space since input
    // ends with a newline).
    basicRawText = END_EDGE_LINE_BOUNDARY_PATTERN.matcher(basicRawText).replaceFirst("");

    // Handle line boundaries in the middle of the raw text. Note we have to check the characters
    // before and after because the line boundaries may be adjacent to HTML tags.
    Matcher matcher = NONEDGE_LINE_BOUNDARY_PATTERN.matcher(basicRawText);
    StringBuffer basicRawTextWithoutNewlinesSb = new StringBuffer(basicRawText.length());
    while (matcher.find()) {
      char charBefore = basicRawText.charAt(matcher.start() - 1);
      char charAfter = basicRawText.charAt(matcher.end());
      matcher.appendReplacement(
          basicRawTextWithoutNewlinesSb, (charBefore == '>' || charAfter == '<') ? "" : " ");
    }
    matcher.appendTail(basicRawTextWithoutNewlinesSb);

    return newSourceItemInfo(
      basicRawTextWithoutNewlinesSb.toString(),
      lineNum,
      columnNum,
      token.endLine,
      token.endColumn
    );
  }
}


/**
 * Matches empty string or BasicRawText, and if the latter, then ensures it's all whitespace.
 * Used for areas that should not have any content (e.g. between 'call' and 'param' tags).
 * TODO(slaks): Change parameters to SoyErrorKind, Object...
 *
 * MaybeWhitespace -> [ BasicRawText ]
 *
 * Package visible for testing.
 */
void MaybeWhitespace(String errorMessage) :
{
  SourceItemInfo<String> basicRawText;
}
{
  [
    basicRawText = BasicRawText()
    { if (basicRawText.parsedContent().trim().length() != 0) {
        errorReporter.report(basicRawText.srcLocation(), SoyErrorKind.of("{0}"), errorMessage);
      }
    }
  ]
}


/**
 * LiteralRawText -> SoyTagOpen CmdNameLiteral RegSoyTagClose LiteralRawTextContent
 */
private SourceItemInfo<String> LiteralRawText() :
{
  Token tag;
  Token literalRawTextContent;
}
{
  tag = <CMD_OPEN_LITERAL>
  literalRawTextContent = <LITERAL_RAW_TEXT_CONTENT>
  { return newSourceItemInfo(literalRawTextContent.image, tag); }
}


/**
 * SpecialCharRawText -> {...}
 */
private SourceItemInfo<String> SpecialCharRawText() :
{
  Token command; String value;
}
{
  (
    command = <CMD_FULL_SP>  { value = " ";  }
  | command = <CMD_FULL_NIL> { value = "";   }
  | command = <CMD_FULL_CR>  { value = "\r"; }
  | command = <CMD_FULL_LF>  { value = "\n"; }
  | command = <CMD_FULL_TAB> { value = "\t"; }
  | command = <CMD_FULL_LB>  { value = "{";  }
  | command = <CMD_FULL_RB>  { value = "}";  }
  )
  { return newSourceItemInfo(value, command); }
}


/**
 * ContiguousRawText -> ( BasicRawText | LiteralRawText | SpecialCharRawText )+
 *
 * May return empty string (due to comments, line joining, etc).
 */
private SourceItemInfo<String> ContiguousRawText() :
{
  SourceItemInfo<String> basicRawText, literalRawText, specialCharRawText;
}
{
  {
    StringBuilder sb = new StringBuilder();
    SourceItemInfo<String> first = null;
    SourceItemInfo<String> last = null;
  }

  (
    // Needed because this can be called before another expansion that can also consume <TOKEN_NL>.
    LOOKAHEAD(2)
    (
      basicRawText = BasicRawText()
      {
        if (first == null) {
          first = basicRawText;
        }
        last = basicRawText;
        sb.append(basicRawText.parsedContent());
      }
    |
      literalRawText = LiteralRawText()
      {
        if (first == null) {
          first = literalRawText;
        }
        last = literalRawText;
        sb.append(literalRawText.parsedContent());
      }
    |
      specialCharRawText = SpecialCharRawText()
      {
        if (first == null) {
          first = specialCharRawText;
        }
        last = specialCharRawText;
        sb.append(specialCharRawText.parsedContent());
      }
    )
  )+

  {
    return newSourceItemInfo(sb.toString(), first, last);
  }
}


// -------------------------------------------------------------------------------------------------
// Other tags.


/**
 * MsgTag -> SoyTagOpen CmdNameMsg WsAfterCmdName CmdText RegSoyTagClose
 */
private SourceItemInfo<String> MsgTag() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_MSG>
  cmdText = CmdText()
  tagEnd = <CMD_END>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


/**
 * FallbackmsgTag -> SoyTagOpen CmdNameFallbackmsg WsAfterCmdName CmdText RegSoyTagClose
 */
private SourceItemInfo<String> FallbackmsgTag() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_FALLBACK_MSG>
  cmdText = CmdText()
  tagEnd = <CMD_END>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


/**
 * PluralTag -> SoyTagOpen CmdNamePlural WsAfterCmdName CmdText RegSoyTagClose
 */
private SourceItemInfo<String> PluralTag() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_PLURAL>
  cmdText = CmdText()
  tagEnd = <CMD_END>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


/**
 * SelectTag -> SoyTagOpen CmdNameSelect WsAfterCmdName CmdText RegSoyTagClose
 */
private SourceItemInfo<String> SelectTag() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_SELECT>
  cmdText = CmdText()
  tagEnd = <CMD_END>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


/**
 * PrintTag -> SoyTagOpen [ CmdNamePrint WsAfterCmdName ] CmdTextParts RegSoyTagClose
 * This will also capture invalid forms of actual commands that did not match those commands' actual
 * tokens (eg, `{else blah}`), then try to parse them as implicit prints.  We check for these errors
 * here, catching any kind of invalid construction that starts with { and is not matched by a token.
 */
private SourceItemInfo<List<String>> PrintTag() :
{
  Token tagBegin, tagEnd;
  List<String> cmdTextParts;
  List<String> printTagParts = Lists.newArrayList();
}
{

  (
    tagBegin = <CMD_BEGIN_PRINT>  { printTagParts.add("print"); }
  | tagBegin = <CMD_BEGIN_IMPLICIT_PRINT>  // Implicit print
  )
  cmdTextParts = CmdTextParts()
  { printTagParts.addAll(cmdTextParts); }
  tagEnd = <CMD_END>

  {
    if (printTagParts.isEmpty()) {
      // This error is reported in the command, to catch both {print} and {}.
    } else if (printTagParts.get(0).startsWith("/")) {
      errorReporter.report(createSrcLoc(tagBegin, tagEnd), UNEXPECTED_CLOSING_TAG,
          "{" + Joiner.on("").join(printTagParts) + "}");
    } else if (printTagParts.get(0).startsWith("@")) {
      errorReporter.report(createSrcLoc(tagBegin, tagEnd), INVALID_DECLARATION,
          "{" + printTagParts.get(0));
    } else if (printTagParts.get(0).startsWith("{")) {
      errorReporter.report(createSrcLoc(tagBegin, tagEnd), FOUND_DOUBLE_BRACE);
    } else if (INVALID_PRINT_FILE_PREFIX_PATTERN.matcher(printTagParts.get(0)).matches()) {
      errorReporter.report(createSrcLoc(tagBegin, tagEnd), INVALID_PRINT_FILE_COMMAND,
          "{" + printTagParts.get(0));
    } else if (INVALID_PRINT_PREFIX_PATTERN.matcher(printTagParts.get(0)).matches()) {
      errorReporter.report(createSrcLoc(tagBegin, tagEnd), INVALID_PRINT_PREFIX,
          "{" + printTagParts.get(0));
    }
    return newSourceItemInfo(printTagParts, tagBegin, tagEnd);
  }
}


/**
 * XidTag -> SoyTagOpen CmdNameXid WsAfterCmdName CmdText RegSoyTagClose
 */
private SourceItemInfo<String> XidTag() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_XID>
  cmdText = CmdText()
  tagEnd = <CMD_END>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


/**
 * CssTag -> SoyTagOpen CmdNameCss WsAfterCmdName CmdText RegSoyTagClose
 */
private SourceItemInfo<String> CssTag() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_CSS>
  cmdText = CmdText()
  tagEnd = <CMD_END>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


/**
 * LetTagSelfEnding -> SoyTagOpen CmdNameLet WsAfterCmdName CmdText SelfEndingSoyTagClose
 */
private SourceItemInfo<String> LetTagSelfEnding() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_LET>
  cmdText = CmdText()
  tagEnd = <CMD_SELF_CLOSE>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


/**
 * LetTagNotSelfEnding -> SoyTagOpen CmdNameLet WsAfterCmdName CmdText RegSoyTagClose
 */
private SourceItemInfo<String> LetTagNotSelfEnding() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_LET>
  cmdText = CmdText()
  tagEnd = <CMD_END>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


/**
 * IfTag -> SoyTagOpen CmdNameIf WsAfterCmdName CmdText RegSoyTagClose
 */
private SourceItemInfo<String> IfTag() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_IF>
  cmdText = CmdText()
  tagEnd = <CMD_END>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


/**
 * ElseifTag -> SoyTagOpen CmdNameElseif WsAfterCmdName CmdText RegSoyTagClose
 */
private SourceItemInfo<String> ElseifTag() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_ELSEIF>
  cmdText = CmdText()
  tagEnd = <CMD_END>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


/**
 * SwitchTag -> SoyTagOpen CmdNameSwitch WsAfterCmdName CmdText RegSoyTagClose
 */
private SourceItemInfo<String> SwitchTag() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_SWITCH>
  cmdText = CmdText()
  tagEnd = <CMD_END>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


/**
 * ForeachTag -> SoyTagOpen CmdNameForeach WsAfterCmdName CmdText RegSoyTagClose
 */
private SourceItemInfo<String> ForeachTag() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_FOREACH>
  cmdText = CmdText()
  tagEnd = <CMD_END>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


/**
 * ForTag -> SoyTagOpen CmdNameFor WsAfterCmdName CmdText RegSoyTagClose
 */
private SourceItemInfo<String> ForTag() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_FOR>
  cmdText = CmdText()
  tagEnd = <CMD_END>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


/**
 * AnyCallTagSelfEnding -> SoyTagOpen CmdNameAnyCall WsAfterCmdName CmdTextParts
 *                         SelfEndingSoyTagClose
 */
private SourceItemInfo<List<String>> AnyCallTagSelfEnding() :
{
  Token tagBegin, tagEnd;
  List<String> cmdTextParts;
}
{
  { List<String> callTagParts = Lists.newArrayList(); }

  tagBegin = <CMD_BEGIN_CALL>
  { callTagParts.add(tagBegin.image.substring(1)); }  // Strip {
  cmdTextParts = CmdTextParts()
  { callTagParts.addAll(cmdTextParts); }
  tagEnd = <CMD_SELF_CLOSE>

  { return newSourceItemInfo(callTagParts, tagBegin, tagEnd); }
}


/**
 * AnyCallTagNotSelfEnding -> SoyTagOpen CmdNameAnyCall WsAfterCmdName CmdTextParts RegSoyTagClose
 */
private SourceItemInfo<List<String>> AnyCallTagNotSelfEnding() :
{
  Token tagBegin, tagEnd;
  List<String> cmdTextParts;
}
{
  { List<String> callTagParts = Lists.newArrayList(); }

  tagBegin = <CMD_BEGIN_CALL>
  { callTagParts.add(tagBegin.image.substring(1)); }  // Strip {
  cmdTextParts = CmdTextParts()
  { callTagParts.addAll(cmdTextParts); }
  tagEnd = <CMD_END>

  { return newSourceItemInfo(callTagParts, tagBegin, tagEnd); }
}


/**
 * ParamTagSelfEnding -> SoyTagOpen CmdNameParam WsAfterCmdName CmdText SelfEndingSoyTagClose
 */
private SourceItemInfo<String> ParamTagSelfEnding() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_PARAM>
  cmdText = CmdText()
  tagEnd = <CMD_SELF_CLOSE>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


/**
 * ParamTagNotSelfEnding -> SoyTagOpen CmdNameParam WsAfterCmdName CmdText RegSoyTagClose
 */
private SourceItemInfo<String> ParamTagNotSelfEnding() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_PARAM>
  cmdText = CmdText()
  tagEnd = <CMD_END>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


// -------------------------------------------------------------------------------------------------
// Shared tags.


/**
 * CaseTag -> SoyTagOpen CmdNameCase WsAfterCmdName CmdText RegSoyTagClose
 *
 * Note: Shared between 'switch', 'plural', and 'select'.
 */
private SourceItemInfo<String> CaseTag() :
{
  Token tagBegin, tagEnd;
  String cmdText;
}
{
  tagBegin = <CMD_BEGIN_CASE>
  cmdText = CmdText()
  tagEnd = <CMD_END>

  { return newSourceItemInfo(cmdText, tagBegin, tagEnd); }
}


// =================================================================================================
// Grammar
// =================================================================================================

// -------------------------------------------------------------------------------------------------
// Template header.


/**
 * Important: The template header must always:
 * (1) contain at least one declaration, and
 * (2) end with a string of whitespace that includes at least one newline.
 *
 * TemplateHeader -> ( [ HeaderConsecWs ] Decl )+ HeaderConsecWsWithNl
 */
private List<DeclInfo> TemplateHeader() :
{
  DeclInfo declInfo;
}
{
  { List<DeclInfo> declInfos = Lists.newArrayList(); }

  (
    LOOKAHEAD( TemplateHeaderLookaheadHelper() )
    [ HeaderConsecWs() ]
    declInfo = Decl() { declInfos.add(declInfo); }
  )+

  // Note that this also consumes the the leading indent that follows the header.
  // TODO(lukes): Why on earth do we require a newline? Change to [ HeaderConsecWsWithNl ]?
  [ HeaderConsecWsNoNl() ] <TOKEN_NL> [ HeaderConsecWsNoNl() ]

  { return declInfos; }
}


/**
 * Helper for use in LOOKAHEAD to check for Decl preceded by optional whitespace.
 * Necessary to stop parser from looking for normal commands instead of headers when the headers are
 * following whitepace and doc comments.
 *
 * TemplateHeaderLookaheadHelper -> [ <BLOCK_DOC_COMMENT> ] [ HeaderConsecWs ]
 *     SoyTagOpen <CMD_NAME_PARAM_DECL> | <CMD_NAME_INJECTED_PARAM_DECL> [ QMARK ] WsAfterCmdName
 */
private void TemplateHeaderLookaheadHelper() :
{}
{
  [ HeaderConsecWs() ]
  [ <BLOCK_DOC_COMMENT> [ HeaderConsecWs() ] ]
  ( <DECL_BEGIN_PARAM> | <DECL_BEGIN_INJECT_PARAM> )
}


/**
 * Decl -> ParamDecl | ParamDeclWithDocPrefix
 */
private DeclInfo Decl() :
{
  DeclInfo declInfo;
}
{
  (
    declInfo = ParamDecl()
    { return declInfo; }
  |
    declInfo = ParamDeclWithDocPrefix()
    { return declInfo; }
  )
}


/**
 * ParamDecl -> SoyTagOpen ( <CMD_NAME_PARAM_DECL> | <CMD_NAME_INJECTED_PARAM_DECL> )
 *              [ <QMARK> ] <WS_AFTER_CMD_NAME> CmdText RegSoyTagClose
 *              [ ( TokenWsNotNl )* BlockDocComment ]
 */
private DeclInfo ParamDecl() :
{
  Token tagBegin, name, paramType, tagEnd;
  String cmdText;
  String desc;
  Token blockDocComment;
  DeclInfo.OptionalStatus optionalStatus = DeclInfo.OptionalStatus.REQUIRED;
  DeclInfo.Type type = DeclInfo.Type.PARAM;
}
{
  (
    tagBegin = <DECL_BEGIN_PARAM>
  | tagBegin = <DECL_BEGIN_INJECT_PARAM> { type = DeclInfo.Type.INJECTED_PARAM; }
  )

  [ <QMARK> { optionalStatus = DeclInfo.OptionalStatus.OPTIONAL; } ]
  (<WS>)+

  name = <NAME>
  <CMD_TYPE_PREFIX>
  paramType = <CMD_TYPE_LITERAL>  // TODO(slaks): Directly invoke type parser.
  tagEnd = <CMD_END>

  (
    LOOKAHEAD( ( <TOKEN_WS_NOT_NL> )* <BLOCK_DOC_COMMENT> )

    (
      <TOKEN_WS_NOT_NL>
    )*

    blockDocComment = <BLOCK_DOC_COMMENT>
    {
      desc = blockDocComment.image;
    }
  |
    {
      desc = null;
    }
  )

  {
    return new DeclInfo(type, optionalStatus, name.image, paramType.image, desc,
        createSrcLoc(tagBegin, tagEnd));
  }
}


/**
 * ParamDeclWithDocPrefix -> BlockDocComment [ HeaderConsecWs ] SoyTagOpen
 *                           ( <CMD_NAME_PARAM_DECL> | <CMD_NAME_INJECTED_PARAM_DECL> )
 *                           [ <QMARK> ] <WS_AFTER_CMD_NAME> CmdText RegSoyTagClose
 *                           [ ( TokenWsNotNl )* BlockDocComment ]
 */
private DeclInfo ParamDeclWithDocPrefix() :
{
  Token blockDocComment, name, paramType;
  DeclInfo.OptionalStatus optionalStatus = DeclInfo.OptionalStatus.REQUIRED;
  DeclInfo.Type type = DeclInfo.Type.PARAM;
}
{
  blockDocComment = <BLOCK_DOC_COMMENT>
  [ HeaderConsecWs() ]

  (
    <DECL_BEGIN_PARAM>
  | <DECL_BEGIN_INJECT_PARAM> { type = DeclInfo.Type.INJECTED_PARAM; }
  )

  [ <QMARK> { optionalStatus = DeclInfo.OptionalStatus.OPTIONAL; } ]
  (<WS>)+

  name = <NAME>
  <CMD_TYPE_PREFIX>
  paramType = <CMD_TYPE_LITERAL>  // TODO(slaks): Directly invoke type parser.
  <CMD_END>

  {
    return new DeclInfo(type, optionalStatus, name.image, paramType.image, blockDocComment.image,
        createSrcLoc(blockDocComment));
  }
}


// -------------------------------------------------------------------------------------------------
// Template block.


/**
 * TemplateBlock -> ( ContiguousRawTextAsNode | Stmt )*
 */
private List<StandaloneNode> TemplateBlock() :
{
  RawTextNode contiguousRawTextAsNode;
  StatementNode stmt;
}
{
  { List<StandaloneNode> templateBlock = Lists.newArrayList(); }

  (
    contiguousRawTextAsNode = ContiguousRawTextAsNode()
    { if (contiguousRawTextAsNode != null) templateBlock.add(contiguousRawTextAsNode); }
  // TODO(lukes): Figure out something non-null to return instead.
  | stmt = Stmt() { if (stmt != null) { templateBlock.add(stmt); } }
  )*

  { return templateBlock; }
}


/**
 * ContiguousRawTextAsNode -> ContiguousRawText
 *
 * May return null if the raw text ends up empty (due to comments, line joining, etc).
 */
private RawTextNode ContiguousRawTextAsNode() :
{
  SourceItemInfo<String> contiguousRawText;
}
{
  contiguousRawText = ContiguousRawText()
  {
    if (contiguousRawText.parsedContent().isEmpty()) {
      return null;
    }
    return new RawTextNode(
        nodeIdGen.genId(), contiguousRawText.parsedContent(), contiguousRawText.srcLocation());
  }
}


// -------------------------------------------------------------------------------------------------
// Soy statements.


/**
 * Stmt ->   MsgStmt | PrintStmt | XidStmt | CssStmt | LetStmt | IfStmt | SwitchStmt
 *         | ForeachStmt | ForStmt| CallStmt | LogStmt | DebuggerStmt
 */
private StatementNode Stmt() :
{
  StatementNode stmt;
}
{
  (
    stmt = MsgStmt()
  | stmt = XidStmt()
  | stmt = CssStmt()
  | stmt = LetStmt()
  | stmt = IfStmt()
  | stmt = SwitchStmt()
  | stmt = ForeachStmt()
  | stmt = ForStmt()
  | stmt = CallStmt()
  | stmt = LogStmt()
  | stmt = DebuggerStmt()
  | stmt = PrintStmt()
  )

  { return stmt; }
}


/**
 * MsgStmt -> MsgTag TemplateBlockForMsg ( FallbackmsgTag TemplateBlockForMsg )? EndMsgTag
 */
private MsgFallbackGroupNode MsgStmt() :
{
  SourceItemInfo<String> cmdText;
  List<StandaloneNode> templateBlockForMsg;
}
{
  { MsgNode msgNode; }

  cmdText = MsgTag()
  {
    MsgFallbackGroupNode msgFbGrpNode = new MsgFallbackGroupNode(
        nodeIdGen.genId(), cmdText.srcLocation());
    msgNode = MsgNode.msg(nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation())
        .build(context);
    msgFbGrpNode.addChild(msgNode);
  }
  templateBlockForMsg = TemplateBlockForMsg()
  { msgNode.addChildren(templateBlockForMsg); }

  (
    cmdText = FallbackmsgTag()
    {
      msgNode = MsgNode.fallbackmsg(
          nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation())
          .build(context);
      msgFbGrpNode.addChild(msgNode);
    }
    templateBlockForMsg = TemplateBlockForMsg()
    { msgNode.addChildren(templateBlockForMsg); }
  )?

  <CMD_CLOSE_MSG>

  { return msgFbGrpNode; }
}


/**
 * TemplateBlockForMsg ->   MaybeWhitespace MsgPlural MaybeWhitespace
 *                        | MaybeWhitespace MsgSelect MaybeWhitespace
 *                        | ( ContiguousRawTextAsNode | Stmt | MsgHtmlTag )*
 */
private List<StandaloneNode> TemplateBlockForMsg() :
{
  RawTextNode contiguousRawTextAsNode;
  MsgPlaceholderInitialNode stmt;
  MsgHtmlTagNode msgHtmlTag;
  MsgPluralNode msgPlural;
  MsgSelectNode msgSelect;
}
{
  { List<StandaloneNode> templateBlock = Lists.newArrayList(); }

  (
    // TODO(lukes): Move this error check out of the parse phase.
    LOOKAHEAD( MaybeWhitespace("") <CMD_BEGIN_PLURAL> )
    MaybeWhitespace("No message content is allowed before a 'plural' block.")
    msgPlural = MsgPlural()
    { templateBlock.add(msgPlural); }
    MaybeWhitespace("No message content is allowed after a 'plural' block.")

  |
    LOOKAHEAD( MaybeWhitespace("") <CMD_BEGIN_SELECT> )
    MaybeWhitespace("No message content is allowed before a 'select' block.")
    msgSelect = MsgSelect()
    { templateBlock.add(msgSelect); }
    MaybeWhitespace("No message content is allowed after a 'select' block.")

  |
    (
      (
        contiguousRawTextAsNode = ContiguousRawTextAsNode()
        { if (contiguousRawTextAsNode != null) templateBlock.add(contiguousRawTextAsNode); }

      | stmt = CallStmt()  { templateBlock.add(new MsgPlaceholderNode(nodeIdGen.genId(), stmt)); }
      | stmt = PrintStmt() {  // TODO(lukes): Figure out something non-null to return instead.
        if (stmt != null) { templateBlock.add(new MsgPlaceholderNode(nodeIdGen.genId(), stmt)); }
      }
      | msgHtmlTag = MsgHtmlTag()
        { templateBlock.add(new MsgPlaceholderNode(nodeIdGen.genId(), msgHtmlTag)); }
      )
    )*
  )

  { return templateBlock; }
}


/**
 * MsgPlural -> PluralTag MaybeWhitespace ( CaseTag TemplateBlockForMsg )*
 *              DefaultTag TemplateBlockForMsg EndPluralTag
 */
private MsgPluralNode MsgPlural() :
{
  Token defaultTag;
  SourceItemInfo<String> cmdText;
  List<StandaloneNode> templateBlockForMsg;
}
{
  cmdText = PluralTag()
  {
    MsgPluralNode msgPluralNode = new MsgPluralNode.Builder(
        nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation())
        .build(context);
  }
  MaybeWhitespace("No content allowed between 'plural' and 'case'" +
      " (whitespace and comments are okay).")

  (
    cmdText = CaseTag()
    {
      MsgPluralCaseNode msgPluralCaseNode = new MsgPluralCaseNode.Builder(
          nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation())
          .build(errorReporter);
      msgPluralNode.addChild(msgPluralCaseNode);
    }
    templateBlockForMsg = TemplateBlockForMsg()
    { if (templateBlockForMsg.size() == 1 &&
          (templateBlockForMsg.get(0) instanceof MsgPluralNode ||
           templateBlockForMsg.get(0) instanceof MsgSelectNode )) {
        errorReporter.report(
            templateBlockForMsg.get(0).getSourceLocation(),
            PLURAL_AND_SELECT_NOT_ALLOWED_INSIDE_PLURAL_BLOCK);
      }
      msgPluralCaseNode.addChildren(templateBlockForMsg);
    }
  )*

  defaultTag = <CMD_FULL_DEFAULT>
  {
    MsgPluralDefaultNode msgPluralDefaultNode = new MsgPluralDefaultNode(
        nodeIdGen.genId(), createSrcLoc(defaultTag));
    msgPluralNode.addChild(msgPluralDefaultNode);
  }
  templateBlockForMsg = TemplateBlockForMsg()
  { if (templateBlockForMsg.size() == 1 &&
        (templateBlockForMsg.get(0) instanceof MsgPluralNode ||
         templateBlockForMsg.get(0) instanceof MsgSelectNode )) {
      errorReporter.report(
          templateBlockForMsg.get(0).getSourceLocation(),
          PLURAL_AND_SELECT_NOT_ALLOWED_INSIDE_PLURAL_BLOCK);
    }
    msgPluralDefaultNode.addChildren(templateBlockForMsg);
  }

  <CMD_CLOSE_PLURAL>

  { return msgPluralNode; }
}


/**
 * MsgSelect -> SelectTag MaybeWhitespace ( CaseTag TemplateBlockForMsg )*
 *              DefaultTag TemplateBlockForMsg EndSelectTag
 */
private MsgSelectNode MsgSelect() :
{
  Token defaultTag;
  SourceItemInfo<String> cmdText;
  List<StandaloneNode> templateBlockForMsg;
}
{
  cmdText = SelectTag()
  {
    MsgSelectNode msgSelectNode = new MsgSelectNode.Builder(
        nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation()).build(context);
  }
  MaybeWhitespace("No content allowed between 'select' and 'case'" +
      " (whitespace and comments are okay).")

  (
    cmdText = CaseTag()
    {
      MsgSelectCaseNode msgSelectCaseNode = new MsgSelectCaseNode.Builder(
          nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation())
          .build(context);
      msgSelectNode.addChild(msgSelectCaseNode);
    }
    templateBlockForMsg = TemplateBlockForMsg()
    { msgSelectCaseNode.addChildren(templateBlockForMsg); }
  )*

  defaultTag = <CMD_FULL_DEFAULT>
  {
    MsgSelectDefaultNode msgSelectDefaultNode
        = new MsgSelectDefaultNode(nodeIdGen.genId(), createSrcLoc(defaultTag));
    msgSelectNode.addChild(msgSelectDefaultNode);
  }
  templateBlockForMsg = TemplateBlockForMsg()
  { msgSelectDefaultNode.addChildren(templateBlockForMsg); }

  <CMD_CLOSE_SELECT>

  { return msgSelectNode; }
}


/**
 * MsgHtmlTag -> MsgHtmlTagOpen TemplateBlock MsgHtmlTagClose
 */
private MsgHtmlTagNode MsgHtmlTag() :
{
  Token htmlTagOpen;
  List<StandaloneNode> templateBlock;
}
{
  htmlTagOpen = <MSG_HTML_TAG_OPEN>
  templateBlock = TemplateBlock()
  <MSG_HTML_TAG_CLOSE>

  {
    SourceLocation srcLoc = createSrcLoc(htmlTagOpen);
    // TODO(lukes): Massively simplify this by creating more nodes.  Also fix SourceLocation.
    // First, we add back the HTML tag's opening and closing angle brackets.
    // Minor note: If there's only one RawTextNode, we'll replace it twice. No big deal.
    if (templateBlock.get(0) instanceof RawTextNode) {
      RawTextNode firstNode = (RawTextNode) templateBlock.get(0);
      RawTextNode newNode = new RawTextNode(
          nodeIdGen.genId(), "<" + firstNode.getRawText(), srcLoc);
      templateBlock.set(0, newNode);
    } else {
      templateBlock.add(0, new RawTextNode(nodeIdGen.genId(), "<", srcLoc));
    }
    int lastNodeIndex = templateBlock.size() - 1;
    if (templateBlock.get(lastNodeIndex) instanceof RawTextNode) {
      RawTextNode lastNode = (RawTextNode) templateBlock.get(lastNodeIndex);
      RawTextNode newNode = new RawTextNode(nodeIdGen.genId(), lastNode.getRawText() + ">", srcLoc);
      templateBlock.set(lastNodeIndex, newNode);
    } else {
      templateBlock.add(new RawTextNode(nodeIdGen.genId(), ">", srcLoc));
    }
    return new MsgHtmlTagNode.Builder(
        nodeIdGen.genId(),
        ImmutableList.copyOf(templateBlock),
        createSrcLoc(htmlTagOpen))
        .build(errorReporter);
  }
}


/**
 * PrintStmt -> PrintTag
 */
private PrintNode PrintStmt() :
{
  SourceItemInfo<List<String>> printTagInfo;
}
{
  printTagInfo = PrintTag()

  {
    List<String> printTagParts = printTagInfo.parsedContent();

    // ------ Process command name (implicit or explicit). ------
    boolean isImplicit;
    List<String> cmdTextParts;
    if (!printTagParts.isEmpty() && printTagParts.get(0).equals("print")) {
      isImplicit = false;
      cmdTextParts = printTagParts.subList(1, printTagParts.size());
    } else {
      isImplicit = true;
      cmdTextParts = printTagParts;
    }
    String cmdText = Joiner.on("").join(cmdTextParts);

    // ------ Process 'phname' attribute (if any). ------
    String phnameAttr = null;
    for (String cmdTextPart : cmdTextParts) {
      if (cmdTextPart.startsWith(" phname=\"") && cmdTextPart.endsWith("\"")) {
        if (phnameAttr != null) {
          errorReporter.report(
              printTagInfo.srcLocation(), MULTIPLE_PHNAME_ATTRIBUTES_IN_COMMAND, "print", cmdText);
        }
        phnameAttr = cmdTextPart;
      }
    }
    String userSuppliedPhName;
    if (phnameAttr != null) {
      cmdTextParts.remove(phnameAttr);
      userSuppliedPhName = phnameAttr.substring(9, phnameAttr.length() - 1);
    } else {
      userSuppliedPhName = null;
    }

    // ------ Process expression. ------
    // Note: First part is expression, rest of parts are directives or directive args.
    if (cmdTextParts.isEmpty()) {
      errorReporter.report(printTagInfo.srcLocation(), PRINT_COMMAND_WITH_EMPTY_TEXT);
      return null;
    }
    String exprText = cmdTextParts.get(0).trim();
    PrintNode printNode
        = new PrintNode.Builder(nodeIdGen.genId(), isImplicit, printTagInfo.srcLocation())
            .exprText(exprText)
            .userSuppliedPlaceholderName(userSuppliedPhName)
            .build(context);

    // ------ Process directives (if any). ------
    String directiveName = null;
    for (int i = 1, n = cmdTextParts.size(); i < n; i++) {
      String cmdTextPart = cmdTextParts.get(i);

      if (cmdTextPart.startsWith("|")) {
        // Create previous directive and save current directive name.
        if (directiveName != null) {
          printNode.addChild(new PrintDirectiveNode.Builder(
              nodeIdGen.genId(), directiveName, "", printTagInfo.srcLocation())
              .build(context));
        }
        directiveName = cmdTextPart;

      } else if (cmdTextPart.startsWith(":")) {
        // Create previous directive with current args text.
        if (directiveName == null) {
          throw new AssertionError();
        }
        String argsText = cmdTextPart.substring(1);
        printNode.addChild(new PrintDirectiveNode.Builder(
            nodeIdGen.genId(), directiveName, argsText, printTagInfo.srcLocation())
            .build(context));
        directiveName = null;

      } else if (cmdTextPart.trim().length() == 0) {
        continue;

      } else {
        errorReporter.report(printNode.getSourceLocation(), INVALID_PRINT_COMMAND_TEXT, cmdText);
      }
    }
    // Add last directive.
    if (directiveName != null) {
      printNode.addChild(new PrintDirectiveNode.Builder(
          nodeIdGen.genId(), directiveName, "", printTagInfo.srcLocation())
          .build(context));
    }

    return printNode;
  }
}


/**
 * XidStmt -> XidTag
 */
private XidNode XidStmt() :
{
  SourceItemInfo<String> cmdText;
}
{
  cmdText = XidTag()
  {
    return new XidNode.Builder(nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation())
        .build(errorReporter);
  }
}


/**
 * CssStmt -> CssTag
 */
private CssNode CssStmt() :
{
  SourceItemInfo<String> cmdText;
}
{
  cmdText = CssTag()
  {
    return new CssNode.Builder(nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation())
        .build(context);
  }
}


/**
 * LetStmt ->   LetTagSelfEnding
 *            | LetTagNotSelfEnding TemplateBlock EndLetTag
 */
private LetNode LetStmt() :
{
  SourceItemInfo<String> cmdText;
  List<StandaloneNode> templateBlock;
}
{
  { LetNode letNode = null; }

  (
    LOOKAHEAD( LetTagSelfEnding() )

    cmdText = LetTagSelfEnding()
    {
      letNode = new LetValueNode.Builder(
          nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation())
          .build(context);
    }

  |

    cmdText = LetTagNotSelfEnding()
    {
      LetContentNode letContentNode = new LetContentNode.Builder(
            nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation())
            .build(context);
    }
    templateBlock = TemplateBlock()
    { letContentNode.addChildren(templateBlock);
      letNode = letContentNode;
    }
    <CMD_CLOSE_LET>
  )

  { return letNode; }
}


/**
 * IfStmt -> IfTag TemplateBlock ( ElseifTag TemplateBlock )* [ ElseTag TemplateBlock ] EndIfTag
 */
private IfNode IfStmt() :
{
  SourceItemInfo<String> cmdText;
  List<StandaloneNode> templateBlock;
  Token elseTag;
}
{
  { IfCondNode ifCondNode; }

  cmdText = IfTag()
  {
    IfNode ifNode = new IfNode(nodeIdGen.genId(), cmdText.srcLocation());
    ifCondNode = IfCondNode.ifBuilder(
        nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation())
        .build(context);
    ifNode.addChild(ifCondNode);
  }
  templateBlock = TemplateBlock()
  { ifCondNode.addChildren(templateBlock); }

  (
    cmdText = ElseifTag()
    {
      ifCondNode = IfCondNode.elseifBuilder(
          nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation()).build(context);
      ifNode.addChild(ifCondNode);
    }
    templateBlock = TemplateBlock()
    { ifCondNode.addChildren(templateBlock); }
  )*

  [

    elseTag = <CMD_FULL_ELSE>
    {
      IfElseNode ifElseNode = new IfElseNode(nodeIdGen.genId(), createSrcLoc(elseTag));
      ifNode.addChild(ifElseNode);
    }
    templateBlock = TemplateBlock()
    { ifElseNode.addChildren(templateBlock); }
  ]

  <CMD_CLOSE_IF>

  { return ifNode; }
}


/**
 * SwitchStmt -> SwitchTag MaybeWhitespace ( CaseTag TemplateBlock )* [ DefaultTag TemplateBlock ]
 *               EndSwitchTag
 */
private SwitchNode SwitchStmt() :
{
  SourceItemInfo<String> cmdText;
  Token defaultTag;
  List<StandaloneNode> templateBlock;
}
{
  cmdText = SwitchTag()
  {
    SwitchNode switchNode = new SwitchNode.Builder(
        nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation())
        .build(context);
  }

  MaybeWhitespace("No content allowed between 'switch' and 'case'" +
      " (whitespace and comments are okay).")

  (
    cmdText = CaseTag()
    {
      SwitchCaseNode switchCaseNode = new SwitchCaseNode.Builder(
          nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation())
          .build(context);
      switchNode.addChild(switchCaseNode);
    }
    templateBlock = TemplateBlock()
    { switchCaseNode.addChildren(templateBlock); }
  )*

  [
    defaultTag = <CMD_FULL_DEFAULT>
    {
      SwitchDefaultNode switchDefaultNode = new SwitchDefaultNode(
          nodeIdGen.genId(), createSrcLoc(defaultTag));
      switchNode.addChild(switchDefaultNode);
    }
    templateBlock = TemplateBlock()
    { switchDefaultNode.addChildren(templateBlock); }
  ]

  <CMD_CLOSE_SWITCH>

  { return switchNode; }
}


/**
 * ForeachStmt -> ForeachTag TemplateBlock [ IfemptyTag TemplateBlock ] EndForeachTag
 */
private ForeachNode ForeachStmt() :
{
  SourceItemInfo<String> cmdText;
  List<StandaloneNode> templateBlock;
  Token ifemptyTag;
}
{
  cmdText = ForeachTag()
  {
    ForeachBuilder builder = ForeachBuilder.create(nodeIdGen, context)
        .setCommandLocation(cmdText.srcLocation())
        .setCommandText(cmdText.parsedContent());
  }

  templateBlock = TemplateBlock()
  {
    builder.setLoopBody(templateBlock);
  }

  [
    ifemptyTag = <CMD_FULL_IFEMPTY>
    templateBlock = TemplateBlock()
    {
      builder.setIfEmptyBody(createSrcLoc(ifemptyTag), templateBlock);
    }
  ]

  <CMD_CLOSE_FOREACH>

  { return builder.build(); }
}


/**
 * ForStmt -> ForTag TemplateBlock EndForTag
 */
private ForNode ForStmt() :
{
  SourceItemInfo<String> cmdText;
  List<StandaloneNode> templateBlock;
}
{
  cmdText = ForTag()
  {
    ForNode forNode = new ForNode(
        nodeIdGen.genId(),
        cmdText.parsedContent(),
        cmdText.srcLocation(),
        context);
  }

  templateBlock = TemplateBlock()
  { forNode.addChildren(templateBlock); }

  <CMD_CLOSE_FOR>

  { return forNode; }
}


/**
 * CallStmt ->
 *       AnyCallTagSelfEnding
 *     | AnyCallTagNotSelfEnding MaybeWhitespace ( CallParam MaybeWhitespace )* EndAnyCallTag
 */
private CallNode CallStmt() :
{
  SourceItemInfo<List<String>> callTagInfo;
  CallParamNode callParam;
  Token endCallTag;
}
{
  { List<CallParamNode> callParams = Lists.newArrayList(); }

  (
    LOOKAHEAD(AnyCallTagSelfEnding())
    callTagInfo = AnyCallTagSelfEnding()
    { endCallTag = null; }

  |

    callTagInfo = AnyCallTagNotSelfEnding()

    MaybeWhitespace("No content allowed between 'call' and 'param'" +
        " (whitespace and comments are okay).")


    (
      callParam = CallParam()
      { callParams.add(callParam); }
      MaybeWhitespace("No content allowed between 'param' and 'param'" +
          " (whitespace and comments are okay).")
    )*

    endCallTag = <CMD_CLOSE_CALL>
  )

  // TODO(slaks): Get rid of all of these loops (including CmdTextParts).
  // Instead, take (PhName()|CmdText())*, and set phname in {} inside the repetition.
  // Do the same for print statements (also with |directive).
  { List<String> callTagParts = callTagInfo.parsedContent();

    // ------ Divide callTagParts into cmdName, cmdText, and phnameAttr (if any). ------
    String cmdName = callTagParts.get(0);

    StringBuilder cmdTextSb = new StringBuilder();
    String phnameAttr = null;

    for (int i = 1; i < callTagParts.size(); i++) {
      String cmdTextPart = callTagParts.get(i);
      if (cmdTextPart.startsWith(" phname=\"") && cmdTextPart.endsWith("\"")) {
        if (phnameAttr != null) {
          errorReporter.report(
              callTagInfo.srcLocation(),
              MULTIPLE_PHNAME_ATTRIBUTES_IN_COMMAND,
              cmdName,
              Joiner.on("").join(callTagParts.subList(1, callTagParts.size())));
        }
        phnameAttr = cmdTextPart;
      } else {
        cmdTextSb.append(cmdTextPart);
      }
    }

    String cmdText = cmdTextSb.toString();

    // ------ Compute isBasicCallTag and userSuppliedPhName. ------
    boolean isBasicCallTag = callTagParts.get(0).trim().equals("call");
    if (endCallTag != null && !endCallTag.image.equals("{/" + callTagParts.get(0).trim() + "}")) {
      // TODO(slaks): Port to SoyErrorKind.
      if (isBasicCallTag) {
        errorReporter.report(createSrcLoc(endCallTag),
            SoyErrorKind.of("{0}"), "Mismatched 'call' and '/delcall'.");
      } else {
        errorReporter.report(createSrcLoc(endCallTag),
            SoyErrorKind.of("{0}"), "Mismatched 'delcall' and '/call'.");
      }
    }

    String userSuppliedPhName =
        (phnameAttr != null) ? phnameAttr.substring(9, phnameAttr.length() - 1) : null;

    // ------ Create the CallNode. ------
    CallNode callNode = null;
    if (isBasicCallTag) {
      callNode = new CallBasicNode.Builder(nodeIdGen.genId(), callTagInfo.srcLocation())
          .commandText(cmdText)
          .userSuppliedPlaceholderName(userSuppliedPhName)
          .build(context);
    } else {
      callNode = new CallDelegateNode.Builder(nodeIdGen.genId(), callTagInfo.srcLocation())
          .commandText(cmdText)
          .userSuppliedPlaceholderName(userSuppliedPhName)
          .build(context);
    }
    callNode.addChildren(callParams);

    return callNode;
  }
}


/**
 * CallParam ->   ParamTagSelfEnding
 *              | ParamTagNotSelfEnding TemplateBlock EndParamTag
 */
private CallParamNode CallParam() :
{
  SourceItemInfo<String> cmdText;
  List<StandaloneNode> templateBlock;
}
{
  { CallParamNode callParamNode = null; }

  (
    LOOKAHEAD( ParamTagSelfEnding() )

    cmdText = ParamTagSelfEnding()
    {
      callParamNode = new CallParamValueNode.Builder(
          nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation())
          .build(context);
    }

  |

    cmdText = ParamTagNotSelfEnding()
    {
      CallParamContentNode cpcn = new CallParamContentNode.Builder(
          nodeIdGen.genId(), cmdText.parsedContent(), cmdText.srcLocation())
          .build(context);
    }
    templateBlock = TemplateBlock()
    { cpcn.addChildren(templateBlock);
      callParamNode = cpcn;
    }
    <CMD_CLOSE_PARAM>
  )

  { return callParamNode; }
}


/**
 * LogStmt -> LogTag TemplateBlock EndLogTag
 */
private LogNode LogStmt() :
{
  Token open;
  List<StandaloneNode> templateBlock;
}
{
  open = <CMD_OPEN_LOG>
  {
    LogNode logNode = new LogNode(nodeIdGen.genId(), createSrcLoc(open));
  }

  templateBlock = TemplateBlock()
  { logNode.addChildren(templateBlock); }

  <CMD_CLOSE_LOG>

  { return logNode; }
}


/**
 * DebuggerStmt -> DebuggerTag TemplateBlock EndDebuggerTag
 */
private DebuggerNode DebuggerStmt() :
{
  Token token;
}
{
  token = <CMD_FULL_DEBUGGER>
  { return new DebuggerNode(nodeIdGen.genId(), createSrcLoc(token)); }
}


/**
 * TODO(lukes): Delete after porting tests
 */
TemplateParseResult parseTemplateContent() :
{
  List<DeclInfo> headerDecls;
  List<StandaloneNode> bodyNodes;
}
{
  {
    context = SoyParsingContext.empty(errorReporter, "fake.namespace");
    token_source.SwitchTo(TEMPLATE_DEFAULT_AT_SOL);
  }

  (
    LOOKAHEAD( TemplateHeaderLookaheadHelper() )
    headerDecls = TemplateHeader()
  |
    // If no template header, ignore initial indent at start of template body.
    [ LOOKAHEAD(2) HeaderConsecWsNoNl() ]
    { headerDecls = null; }
  )

  bodyNodes = TemplateBlock()

  <EOF>
  { // Note: We're using an undocumented API to check the token manager's state. If this ever
    // breaks due to changes in JavaCC (extremely unlikely since many users around the world are
    // depending on it), then we'll have to use a different method to detect whether we're within
    // a comment block.
    if (token_source.curLexState == IN_BLOCK_DOC_COMMENT ||
        token_source.curLexState == IN_BLOCK_NONDOC_COMMENT) {
      throw new ParseException("At end of template, found comment block that is never closed.");
    }
  }

  { return new TemplateParseResult(headerDecls, bodyNodes); }
}
